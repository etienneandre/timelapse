#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Created      : 2025/11/08
# Last modified: 2025/11/11
# Author       : √âtienne Andr√©
# Disclaimer   : first version obtained as a union of fragments generated by a generative AI chatbot

import os
import sys
import subprocess
import re
import shutil
from datetime import datetime
from PIL import Image, ImageDraw, ImageFont
from PIL.ExifTags import TAGS

import cv2
import numpy as np
import glob #, os
from tqdm import tqdm


VIDEO_NAME = "timelapse.mp4"
# FPS = 4
DURATION_FRAME = "0.1"

############################################################
# PARTIE 1: renommage
############################################################

# TODO: detect if 2 pictures have the same %Y-%m-%d-%H-%M

def extraire_date_exif(chemin_image):
    """Retourne la date/heure EXIF sous forme de datetime, ou None si introuvable."""
    try:
        with Image.open(chemin_image) as img:
            exif_data = img._getexif()
            if not exif_data:
                return None

            for tag, value in exif_data.items():
                tag_name = TAGS.get(tag, tag)
                if tag_name in ("DateTimeOriginal", "DateTime", "DateTimeDigitized"):
                    try:
                        return datetime.strptime(value, "%Y:%m:%d %H:%M:%S")
                    except Exception:
                        return None
        return None
    except Exception:
        return None


def rename_after_exif(repertoire_entree, repertoire_sortie):
    # Extensions d‚Äôimages prises en charge
    extensions_valides = {".jpg", ".jpeg", ".png", ".tiff", ".bmp", ".heic", ".webp"}

    nb_ok = 0
    nb_erreurs = 0

    for nom_fichier in os.listdir(repertoire_entree):
        chemin_entree = os.path.join(repertoire_entree, nom_fichier)

        if not os.path.isfile(chemin_entree):
            continue

        _, ext = os.path.splitext(nom_fichier)
        if ext.lower() not in extensions_valides:
            continue

        date_exif = extraire_date_exif(chemin_entree)

        if date_exif:
            nouveau_nom = f"{prefixe}-{date_exif.strftime('%Y-%m-%d-%H-%M')}{ext.lower()}"
            nb_ok += 1
            chemin_sortie = os.path.join(repertoire_sortie, nouveau_nom)
            # TODO: √©ventuellement v√©rifier ici que le fichier n'existe pas d√©j√†, auquel cas, le renum√©roter
            shutil.copy2(chemin_entree, chemin_sortie)

        else:
            print(f"‚ö†Ô∏è Erreur: pas de donn√©es EXIF valides pour '{nom_fichier}'")
            # NOTE: finalement, on ne copie pas le fichier, oust
            # nouveau_nom = f"erreur-{nom_fichier}"
            nb_erreurs += 1


    print("\n=== R√©sum√© ===")
    print(f"Images converties correctement : {nb_ok}")
    print(f"Images en erreur               : {nb_erreurs}")
    print(f"Fichiers enregistr√©s dans      : {repertoire_sortie}")


############################################################
# PART 2: ALIGNMENT
############################################################

def reprojection_error(H, src_pts, dst_pts, affine=False):
    if affine:
        # src_pts: Nx2
        src_pts_h = np.hstack([src_pts, np.ones((len(src_pts), 1))])
        pred = (H @ src_pts_h.T).T  # Nx2
    else:
        src_pts_h = np.hstack([src_pts, np.ones((len(src_pts), 1))])
        pred_h = (H @ src_pts_h.T).T  # Nx3
        pred = pred_h[:, :2] / pred_h[:, 2:3]

    err = np.linalg.norm(pred - dst_pts, axis=1)
    return np.median(err)  # ou np.mean(err)



def ajouter_date_image(chemin_image):
    # --- 1. Extraire le nom de fichier sans extension ---
    nom_fichier = os.path.basename(chemin_image)

    # --- 2. Trouver la date au format yyyy-mm-dd ---
    match = re.search(r"\d{4}-\d{2}-\d{2}", nom_fichier)
    if not match:
        print("Aucune date trouv√©e dans le nom de fichier :", nom_fichier)
        return
    date_str = match.group(0)

   # --- 3. Charger l‚Äôimage et forcer RGBA ---
    img = Image.open(chemin_image)
    if img.mode != "RGBA":
        img = img.convert("RGBA")

    # --- 4. Police monospace ---
    try:
        font = ImageFont.truetype("DejaVuSansMono.ttf", size=max(20, img.height // 25))
    except IOError:
        font = ImageFont.load_default()

    # --- 5. Mesure du texte ---
    draw_tmp = ImageDraw.Draw(img)
    bbox = draw_tmp.textbbox((0, 0), date_str, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]

    # --- 6. Position bas droite ---
    margin = 10
    x = img.width - text_width - margin
    y = img.height - text_height - margin

    # --- 7. Cr√©er calque overlay RGBA ---
    overlay = Image.new("RGBA", img.size, (0, 0, 0, 0))
    draw_overlay = ImageDraw.Draw(overlay)

    # Fond semi-transparent
    draw_overlay.rectangle(
        [(x - 5, y - 3), (x + text_width + 5, y + text_height + 3)],
        fill=(0, 0, 0, 150)
    )
    # Texte jaune vif
    draw_overlay.text((x, y), date_str, font=font, fill=(255, 255, 0, 255))

    # --- 8. Fusion des calques ---
    img_composite = Image.alpha_composite(img, overlay)

    # --- 9. Conversion finale en RGB pour JPEG ---
    img_final = img_composite.convert("RGB")
    # sortie = os.path.splitext(chemin_image)[0] + "_date.jpg"
    # On √©crase !
    sortie = chemin_image
    img_final.save(sortie, quality=95)
    print("‚úÖ Image enregistr√©e :", sortie)



# TODO: detect aberrations in case none of the 2 alignement methods are accurate enough

def align_images_3(base_img, img_to_align, fname, max_features=5000, good_match_percent=0.15):
    """Aligne img_to_align sur base_img via d√©tection de points cl√©s (ORB) et homographie."""
    # Convertir en niveaux de gris

    # im1_gray = cv2.cvtColor(base_img, cv2.COLOR_BGR2GRAY)
    # im2_gray = cv2.cvtColor(img_to_align, cv2.COLOR_BGR2GRAY)

    # Mieux ?
    im1_gray = cv2.equalizeHist(cv2.cvtColor(base_img, cv2.COLOR_BGR2GRAY))
    im2_gray = cv2.equalizeHist(cv2.cvtColor(img_to_align, cv2.COLOR_BGR2GRAY))

    # D√©tection des points cl√©s et descripteurs
    # BEGIN ORB
    # orb = cv2.ORB_create(max_features)
    # keypoints1, descriptors1 = orb.detectAndCompute(im1_gray, None)
    # keypoints2, descriptors2 = orb.detectAndCompute(im2_gray, None)
    # # Appariement des descripteurs
    # matcher = cv2.DescriptorMatcher_create(cv2.DESCRIPTOR_MATCHER_BRUTEFORCE_HAMMING)
    # END ORB
    # BEGIN AKAZE
    # detector = cv2.AKAZE_create()  # ou cv2.SIFT_create()
    # keypoints1, descriptors1 = detector.detectAndCompute(im1_gray, None)
    # keypoints2, descriptors2 = detector.detectAndCompute(im2_gray, None)
    #
    # # Appariement des descripteurs
    # matcher = cv2.DescriptorMatcher_create(cv2.DESCRIPTOR_MATCHER_BRUTEFORCE_HAMMING)
    # END AKAZE

    detector = cv2.SIFT_create()
    keypoints1, descriptors1 = detector.detectAndCompute(im1_gray, None)
    keypoints2, descriptors2 = detector.detectAndCompute(im2_gray, None)

    # Appariement des descripteurs
    matcher = cv2.DescriptorMatcher_create(cv2.DescriptorMatcher_FLANNBASED)

    # BEGIN SIMPLE COMPARISON
    # # matches = matcher.match(descriptors1, descriptors2, None)
    # matches = list(matcher.match(descriptors1, descriptors2))
    #
    # # Trier selon la qualit√© (distance)
    # matches.sort(key=lambda x: x.distance, reverse=False)
    #
    # # Garder les meilleures correspondances
    # num_good_matches = int(len(matches) * good_match_percent)
    # matches = matches[:num_good_matches]
    # END SIMPLE COMPARISON

    # Appariement avec knn
    potential_matches = matcher.knnMatch(descriptors1, descriptors2, k=2)

    matches = []
    for m, n in potential_matches:
        if m.distance < 0.75 * n.distance:
            matches.append(m)

    # Extraire les points correspondants
    points1 = np.zeros((len(matches), 2), dtype=np.float32)
    points2 = np.zeros((len(matches), 2), dtype=np.float32)
    for i, match in enumerate(matches):
        points1[i, :] = keypoints1[match.queryIdx].pt
        points2[i, :] = keypoints2[match.trainIdx].pt

    height, width, channels = base_img.shape

    # Calcul de la transformation par homographie
    h_homog, mask_h = cv2.findHomography(points2, points1, cv2.RANSAC)

    # Calcul de la transformation affine
    h_affine, mask_a = cv2.estimateAffinePartial2D(points2, points1, method=cv2.RANSAC)

    err_homog = reprojection_error(h_homog, points2, points1, affine=False)
    err_affine = reprojection_error(h_affine, points2, points1, affine=True)

    if err_affine < err_homog:
        use_affine = True
    else:
        use_affine = False

    # if h is None or np.linalg.cond(h) > 1e4:
    #     h, mask = cv2.estimateAffinePartial2D(points2, points1, method=cv2.RANSAC)
    #     if h is not None:
    #         print(f"‚ö†Ô∏è Homographie douteuse pour {fname}, backup vers translation.")
    #         aligned_image = cv2.warpAffine(img_to_align, h, (width, height))
    #     else:
    #         print(f"‚ö†Ô∏è Homographie et translation douteuses pour {fname}, copie non align√©e.")
    #         aligned_image = img_to_align.copy()
    # else:
    #     # Appliquer la transformation homographie
    #     aligned_image = cv2.warpPerspective(img_to_align, h, (width, height))

    h = h_affine

    if use_affine:
        # Appliquer la transformation affine
        aligned_image = cv2.warpAffine(img_to_align, h_affine, (width, height))
        h = h_affine
    else:
        # Appliquer la transformation homographie
        aligned_image = cv2.warpPerspective(img_to_align, h_homog, (width, height))
        h = h_homog
        print(f"‚ö†Ô∏è Meilleure homographie pour {fname}.")

    return aligned_image, h

def align_folder_3(input_dir, output_dir):
    os.makedirs(output_dir, exist_ok=True)
    filenames = sorted([
        f for f in os.listdir(input_dir)
        if f.lower().endswith((".jpg", ".jpeg", ".png", ".tif"))
    ])

    if not filenames:
        print("Aucune image trouv√©e dans", input_dir)
        return

    # Image de r√©f√©rence
    ref_path = os.path.join(input_dir, filenames[0])
    ref_img = cv2.imread(ref_path)
    if ref_img is None:
        raise ValueError(f"Impossible de lire l'image de r√©f√©rence : {ref_path}")

    print(f"Image de r√©f√©rence : {filenames[0]}")

    # Sauvegarder l'image de r√©f√©rence telle quelle
    # TODO: mieux de d'abord cr√©er l'image puis ajouter le texte, et enfin l'exporter dans un fichier
    cv2.imwrite(os.path.join(output_dir, filenames[0]), ref_img)
    ajouter_date_image(os.path.join(output_dir, filenames[0]))

    # Aligner les autres
    for fname in tqdm(filenames[1:], desc="Alignement des images"):
        path = os.path.join(input_dir, fname)
        img = cv2.imread(path)
        if img is None:
            print(f"‚ö†Ô∏è  Impossible de lire {fname}, ignor√©e.")
            continue
        aligned, _ = align_images_3(ref_img, img, fname)
        # TODO: mieux de d'abord cr√©er l'image puis ajouter le texte, et enfin l'exporter dans un fichier
        cv2.imwrite(os.path.join(output_dir, fname), aligned)
        ajouter_date_image(os.path.join(output_dir, fname))

    print(f"\n‚úÖ Toutes les images ont √©t√© align√©es dans : {output_dir}")

# def main_alignement_3(repertoire_sortie_exif, repertoire_sortie_exif_aligne):
#     # import argparse
#     # parser = argparse.ArgumentParser(description="Aligne les images d'un dossier pour timelapse.")
#     # parser.add_argument("input_dir", help="Dossier contenant les images originales")
#     # parser.add_argument("output_dir", help="Dossier o√π sauvegarder les images align√©es")
#     # args = parser.parse_args()
#     # align_folder(args.input_dir, args.output_dir)
#     align_folder_3(repertoire_sortie_exif, repertoire_sortie_exif_aligne)

############################################################
# PART 3: CONVERSION TO VIDEO
############################################################

def photos_to_video_ffmpeg(images_dir, output_file):
    print(f"Conversion des photos dans le r√©pertoire '{images_dir}'‚Ä¶")
    # V√©rifie la pr√©sence du dossier
    if not os.path.isdir(images_dir):
        print("‚ùå Le dossier sp√©cifi√© n'existe pas :", images_dir)
        sys.exit(1)

    # V√©rifie que ffmpeg est install√©
    if subprocess.call(["which", "ffmpeg"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) != 0:
        print("‚ùå ffmpeg n'est pas install√©. Installez-le avec :")
        print("   sudo apt install ffmpeg")
        sys.exit(1)

    # Cr√©e une liste d‚Äôimages tri√©e (pour garantir l‚Äôordre)
    images = sorted([
        f for f in os.listdir(images_dir)
        if f.lower().endswith((".jpg", ".jpeg", ".png", ".bmp"))
    ])

    if not images:
        print("‚ùå Aucune image trouv√©e dans le dossier :", images_dir)
        sys.exit(1)

    # Cr√©e un fichier temporaire listant les images pour ffmpeg
    list_file = os.path.join("images.txt")
    with open(list_file, "w") as f:
        for img in images:
            f.write(f"file '{os.path.join(images_dir, img)}'\n")
            f.write("duration " + DURATION_FRAME + "\n") # NOTE: incompatible with `-r fps`
        # derni√®re image r√©p√©t√©e
        f.write(f"file '{os.path.join(images_dir, images[-1])}'\n")

    print("Fichier temporaire : " + list_file)

    cmd = [
        "ffmpeg",
        "-y",
        "-f", "concat",
        "-safe", "0",
        "-i", list_file,
        # "-r", str(fps),
        "-pix_fmt", "yuv420p",
        output_file
    ]

    print(f"üéûÔ∏è Cr√©ation de la vid√©o '{output_file}' √† dur√©e d‚Äôimage {DURATION_FRAME}s‚Ä¶")
    subprocess.run(cmd, check=True)
    os.remove(list_file)

    print(f"‚úÖ Vid√©o cr√©√©e avec succ√®s : {output_file}")

############################################################
# MAIN
############################################################

if __name__ == "__main__":
    # V√©rification des arguments
    if len(sys.argv) < 2:
        print("Usage : python script.py <repertoire_entree> [prefixe] [repertoire_sortie]")
        sys.exit(1)

    repertoire_entree = sys.argv[1]
    prefixe = sys.argv[2] if len(sys.argv) >= 3 else "exif"

    repertoire_sortie_exif = sys.argv[3] if len(sys.argv) >= 4 else repertoire_entree.rstrip("/\\") + "-exif"
    repertoire_sortie_exif_aligne = repertoire_sortie_exif + "-alignes"


    if not os.path.isdir(repertoire_entree):
        print(f"Erreur : le r√©pertoire d‚Äôentr√©e '{repertoire_entree}' n‚Äôexiste pas.")
        sys.exit(1)

    print("\n=== Entr√©es ===")
    print(f"R√©pertoire source                    : {repertoire_entree}")
    print(f"Pr√©fixe                              : {prefixe}")
    print(f"R√©pertoire de sortie EXIF            : {repertoire_sortie_exif}")
    print(f"R√©pertoire de sortie EXIF alignement : {repertoire_sortie_exif_aligne}")

    os.makedirs(repertoire_sortie_exif, exist_ok=True)


    rename_after_exif(repertoire_entree, repertoire_sortie_exif)
    align_folder_3(repertoire_sortie_exif, repertoire_sortie_exif_aligne)
    photos_to_video_ffmpeg(repertoire_sortie_exif_aligne, VIDEO_NAME)

print("Done! :-)")
